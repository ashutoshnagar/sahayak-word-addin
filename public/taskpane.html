<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sahayak - Document Assistant</title>
    
    <!-- Office.js -->
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js" type="text/javascript"></script>
    
    <!-- Embedded CSS -->
    <style>
        /* Sahayak - Document Assistant Styles */
        
        /* Reset and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.5;
            overflow-x: hidden;
        }
        
        /* Header */
        .sahayak-header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .sahayak-logo h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }
        
        .tagline {
            color: #666;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        /* Main Content */
        .sahayak-main {
            padding: 0;
            min-height: calc(100vh - 140px);
        }
        
        .section {
            padding: 30px 20px;
            background: white;
            margin: 0;
        }
        
        .section.hidden {
            display: none;
        }
        
        /* Welcome Section */
        .welcome-content {
            text-align: center;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .feature-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.8;
        }
        
        .welcome-content h2 {
            font-size: 1.8rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }
        
        .welcome-content p {
            color: #666;
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 30px;
        }
        
        /* Analysis Mode Selection */
        .analysis-modes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 25px 0;
        }
        
        .mode-option {
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            text-align: left;
        }
        
        .mode-option:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
        }
        
        .mode-option.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8f0ff 100%);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }
        
        .mode-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .mode-icon {
            font-size: 1.2rem;
        }
        
        .mode-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #333;
            margin: 0;
        }
        
        .mode-badge {
            margin-left: auto;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: 600;
        }
        
        .mode-badge.new {
            background: #e3f2fd;
            color: #1976d2;
        }
        
        .mode-option p {
            font-size: 0.8rem;
            color: #666;
            margin: 8px 0;
            line-height: 1.4;
        }
        
        .mode-features {
            list-style: none;
            padding: 0;
            margin: 8px 0 0 0;
        }
        
        .mode-features li {
            padding: 2px 0;
            font-size: 0.75rem;
            color: #777;
        }
        
        .mode-features li:before {
            content: "✓ ";
            color: #48bb78;
            font-weight: bold;
            margin-right: 4px;
        }
        
        .selected-mode {
            margin-top: 15px;
            padding: 8px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
        }
        
        .selected-mode small {
            color: #667eea;
            font-weight: 500;
        }
        
        /* Buttons */
        .primary-button, .secondary-button, .fix-button, .ignore-button {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            min-width: 120px;
            justify-content: center;
        }
        
        .primary-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .primary-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .secondary-button {
            background: #f8f9fa;
            color: #666;
            border: 2px solid #e9ecef;
        }
        
        .secondary-button:hover {
            background: #e9ecef;
            border-color: #dee2e6;
        }
        
        .button-icon {
            font-size: 1.1rem;
        }
        
        /* Scanning Section */
        .scanning-animation {
            text-align: center;
            padding: 60px 20px;
        }
        
        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 30px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .scanning-animation h3 {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 10px;
        }
        
        .scanning-animation p {
            color: #666;
        }
        
        /* Results Section */
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f8f9fa;
        }
        
        .results-summary {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .issue-count {
            background: #e3f2fd;
            color: #1976d2;
            padding: 6px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        /* Grammarly-style Issue Groups */
        .issue-groups {
            margin-bottom: 30px;
        }
        
        .main-section {
            margin-bottom: 30px;
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px 20px;
            font-weight: 700;
            font-size: 1.1rem;
            border-radius: 8px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }
        
        .section-header.corrections {
            background: #fff5f5;
            color: #dc2626;
            border: 1px solid #fecaca;
        }
        
        .section-header.refinements {
            background: #eff6ff;
            color: #2563eb;
            border: 1px solid #bfdbfe;
        }
        
        .section-icon {
            font-size: 1.2rem;
        }
        
        .section-count {
            margin-left: auto;
            background: rgba(255, 255, 255, 0.9);
            color: #666;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .issue-types {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .issue-type-group {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        
        .issue-type-group:hover {
            border-color: #d1d5db;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .type-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            cursor: pointer;
            background: #fafafa;
            transition: all 0.2s ease;
        }
        
        .type-header:hover {
            background: #f5f5f5;
        }
        
        .type-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .type-name {
            font-weight: 600;
            color: #374151;
            font-size: 0.95rem;
        }
        
        .type-count {
            background: #e5e7eb;
            color: #6b7280;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .expand-icon {
            color: #9ca3af;
            font-size: 0.8rem;
            transition: transform 0.2s ease;
        }
        
        .issue-type-group.expanded .expand-icon {
            transform: rotate(90deg);
        }
        
        .issue-instances {
            display: none;
            padding: 0;
            background: white;
        }
        
        .issue-type-group.expanded .issue-instances {
            display: block;
        }
        
        .issue-instance {
            padding: 12px 16px;
            border-bottom: 1px solid #f3f4f6;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .issue-instance:hover {
            background: #f9fafb;
        }
        
        .issue-instance:last-child {
            border-bottom: none;
        }
        
        .instance-description {
            color: #6b7280;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }
        
        .instance-location {
            color: #9ca3af;
            font-size: 0.8rem;
        }
        
        /* Color-coded underline styles */
        .underline-critical {
            text-decoration: underline wavy;
            text-decoration-color: #dc2626;
        }
        
        .underline-warning {
            text-decoration: underline dotted;
            text-decoration-color: #f59e0b;
        }
        
        .underline-suggestion {
            text-decoration: underline solid;
            text-decoration-color: #2563eb;
        }
        
        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
        }
        
        /* Error Card Popup */
        .error-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }
        
        .error-card.hidden {
            display: none;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .error-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 20px 0;
        }
        
        .error-type-badge {
            background: #fc8181;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #999;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .close-btn:hover {
            background: #f1f3f4;
            color: #666;
        }
        
        .error-card-content {
            padding: 15px 20px 20px;
        }
        
        .error-card-content h4 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .error-card-content p {
            color: #666;
            line-height: 1.5;
            margin-bottom: 15px;
        }
        
        .error-suggestion {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }
        
        .error-card-actions {
            display: flex;
            gap: 10px;
            padding: 0 20px 20px;
        }
        
        .fix-button {
            background: #48bb78;
            color: white;
            flex: 1;
        }
        
        .fix-button:hover {
            background: #38a169;
        }
        
        .ignore-button {
            background: #e2e8f0;
            color: #4a5568;
            flex: 1;
        }
        
        .ignore-button:hover {
            background: #cbd5e0;
        }
        
        /* Responsive Design */
        @media (max-width: 480px) {
            .sahayak-header {
                padding: 15px;
            }
            
            .sahayak-logo h1 {
                font-size: 2rem;
            }
            
            .section {
                padding: 20px 15px;
            }
            
            .results-header {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }
            
            .results-summary {
                justify-content: space-between;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .error-card {
                width: 95%;
                margin: 0 auto;
            }
        }
        
        /* Utility Classes */
        .hidden {
            display: none !important;
        }
        
        .text-center {
            text-align: center;
        }
        
        .mb-20 {
            margin-bottom: 20px;
        }
        
        .mt-20 {
            margin-top: 20px;
        }
        
        /* Office.js specific overrides */
        .ms-welcome {
            background: none !important;
        }
        
        .ms-font-m {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        }
    </style>
</head>

<body class="ms-font-m ms-welcome ms-Fabric">
    <!-- Header -->
    <header class="sahayak-header">
        <div class="sahayak-logo">
            <h1>सहायक</h1>
            <p class="tagline">Your Intelligent Document Assistant</p>
        </div>
    </header>

    <!-- Main Content -->
    <main class="sahayak-main">
        
        <!-- Welcome Section -->
        <section id="welcome-section" class="section">
            <div class="welcome-content">
                <div class="feature-icon">📋</div>
                <h2>Document Compliance Checker</h2>
                <p>Choose your analysis method for comprehensive document validation</p>
                
                <!-- Analysis Mode Selection -->
                <div class="analysis-modes">
                    <div class="mode-option selected" data-mode="rules">
                        <div class="mode-header">
                            <span class="mode-icon">⚡</span>
                            <h3>Quick Scan</h3>
                            <span class="mode-badge">Current</span>
                        </div>
                        <p>Fast rule-based validation • 2-3 seconds • Free</p>
                        <ul class="mode-features">
                            <li>Font & formatting checks</li>
                            <li>Basic pattern validation</li>
                            <li>Instant results</li>
                        </ul>
                    </div>
                    
                    <div class="mode-option" data-mode="llm">
                        <div class="mode-header">
                            <span class="mode-icon">🧠</span>
                            <h3>AI Analysis</h3>
                            <span class="mode-badge new">New</span>
                        </div>
                        <p>Claude-powered deep analysis • 10-15 seconds • ~$0.02</p>
                        <ul class="mode-features">
                            <li>Contextual understanding</li>
                            <li>Cross-reference validation</li>
                            <li>Complex pattern detection</li>
                        </ul>
                    </div>
                </div>
                
                <button id="scan-document" class="primary-button">
                    <span class="button-icon">🔍</span>
                    <span id="scan-button-text">Scan Document</span>
                </button>
                
                <div class="selected-mode">
                    <small>Selected: <span id="current-mode">Quick Scan</span></small>
                </div>
            </div>
        </section>

        <!-- Scanning Section -->
        <section id="scanning-section" class="section hidden">
            <div class="scanning-animation">
                <div class="loader"></div>
                <h3>Analyzing Document...</h3>
                <p>Sahayak is checking your document against compliance rules</p>
            </div>
        </section>

        <!-- Results Section -->
        <section id="results-section" class="section hidden">
            <div class="results-header">
                <h3>Analysis Results</h3>
                <div class="results-summary">
                    <span id="total-issues" class="issue-count">0 issues found</span>
                    <button id="clear-highlights" class="secondary-button">Clear Highlights</button>
                </div>
            </div>

            <!-- Issue Groups - Grammarly Style -->
            <div class="issue-groups">
                
                <!-- Corrections Section -->
                <div id="corrections-section" class="main-section">
                    <div class="section-header corrections">
                        <span class="section-icon">🔴</span>
                        <h3>Corrections</h3>
                        <span id="corrections-count" class="section-count">0</span>
                    </div>
                    <div id="corrections-groups" class="issue-types"></div>
                </div>

                <!-- Refinements Section -->
                <div id="refinements-section" class="main-section">
                    <div class="section-header refinements">
                        <span class="section-icon">🔵</span>
                        <h3>Refinements</h3>
                        <span id="refinements-count" class="section-count">0</span>
                    </div>
                    <div id="refinements-groups" class="issue-types"></div>
                </div>

            </div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button id="fix-all" class="primary-button">
                    <span class="button-icon">🛠️</span>
                    Fix All Issues
                </button>
                <button id="rescan" class="secondary-button">
                    <span class="button-icon">🔄</span>
                    Rescan Document
                </button>
            </div>

        </section>

    </main>

    <!-- Error Card Popup -->
    <div id="error-card" class="error-card hidden">
        <div class="error-card-header">
            <span id="error-type" class="error-type-badge">Font Error</span>
            <button id="close-error-card" class="close-btn">×</button>
        </div>
        <div class="error-card-content">
            <h4 id="error-title">Error Title</h4>
            <p id="error-description">Error description goes here</p>
            <div class="error-suggestion">
                <strong>Suggestion:</strong>
                <span id="error-suggestion">Suggestion text</span>
            </div>
        </div>
        <div class="error-card-actions">
            <button id="fix-error" class="fix-button">Fix it</button>
            <button id="ignore-error" class="ignore-button">Ignore</button>
        </div>
    </div>

    <!-- Embedded JavaScript -->
    <script>
        // Sahayak - Your Intelligent Document Assistant
        // Main JavaScript with validation rules and Grammarly-like functionality

        class SahayakDocumentAnalyzer {
            constructor() {
                this.errors = [];
                this.highlightedRanges = [];
                this.currentErrorCard = null;
                this.isScanning = false;
                this.analysisMode = 'rules'; // default mode
                
                // Backend configuration
                this.backendConfig = {
                    baseURL: 'https://sahayak-word-addin.vercel.app/api', // Update this with your actual Vercel URL
                    timeout: 30000 // 30 seconds
                };
                
                // Error color mapping
                this.errorColors = {
                    'CRITICAL': '#FF6B6B',
                    'WARNING': '#FFD93D', 
                    'SUGGESTION': '#74C0FC',
                    'FONT_ERROR': '#FF8E53',
                    'FORMAT_ERROR': '#845EC2'
                };
                
                this.initializeEventListeners();
                this.initializeModeSelection();
            }

            initializeEventListeners() {
                document.getElementById('scan-document').addEventListener('click', () => this.scanDocument());
                document.getElementById('clear-highlights').addEventListener('click', () => this.clearHighlights());
                document.getElementById('fix-all').addEventListener('click', () => this.fixAllErrors());
                document.getElementById('rescan').addEventListener('click', () => this.scanDocument());
                document.getElementById('close-error-card').addEventListener('click', () => this.hideErrorCard());
                document.getElementById('fix-error').addEventListener('click', () => this.fixCurrentError());
                document.getElementById('ignore-error').addEventListener('click', () => this.ignoreCurrentError());
            }

            initializeModeSelection() {
                const modeOptions = document.querySelectorAll('.mode-option');
                modeOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        this.selectMode(option.dataset.mode);
                    });
                });
                
                // Set default selection
                this.selectMode('rules');
            }

            selectMode(mode) {
                this.analysisMode = mode;
                
                // Update UI
                document.querySelectorAll('.mode-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                document.querySelector(`[data-mode="${mode}"]`).classList.add('selected');
                
                // Update button text and mode display
                const modeNames = {
                    'rules': 'Quick Scan',
                    'llm': 'AI Analysis'
                };
                
                document.getElementById('current-mode').textContent = modeNames[mode];
                document.getElementById('scan-button-text').textContent = 
                    mode === 'llm' ? 'Analyze with AI' : 'Scan Document';
                
                // Update scanning message
                this.updateScanningMessage();
            }

            updateScanningMessage() {
                const messages = {
                    'rules': 'Running rule-based validation...',
                    'llm': 'AI is analyzing your document...'
                };
                
                const scanningElement = document.querySelector('.scanning-animation p');
                if (scanningElement) {
                    scanningElement.textContent = messages[this.analysisMode] || 'Analyzing document...';
                }
            }

            async scanDocument() {
                if (this.isScanning) return;
                
                this.isScanning = true;
                this.showSection('scanning-section');
                this.updateScanningMessage();
                this.clearHighlights();
                this.errors = [];

                try {
                    // Extract document data
                    const documentData = await this.extractDocumentData();
                    
                    if (this.analysisMode === 'llm') {
                        // Use LLM backend for analysis
                        await this.runLLMValidation(documentData);
                    } else {
                        // Use rule-based validation
                        await this.runValidationRules(documentData);
                    }
                    
                    // Store error ranges for navigation (no permanent highlighting)
                    await this.storeErrorRanges();
                    this.displayResults();
                    this.showSection('results-section');
                    
                } catch (error) {
                    console.error('Error scanning document:', error);
                    
                    // Show user-friendly error message
                    let errorMessage = 'Error scanning document. Please try again.';
                    if (this.analysisMode === 'llm') {
                        errorMessage = 'AI analysis failed. You can try Quick Scan mode instead.';
                    }
                    
                    alert(errorMessage);
                    this.showSection('welcome-section');
                } finally {
                    this.isScanning = false;
                }
            }

            async runLLMValidation(documentData) {
                try {
                    console.log('Starting LLM validation...');
                    
                    // Call backend API
                    const response = await this.callBackendAPI({
                        documentText: documentData.fullText,
                        analysisMode: 'llm',
                        userId: 'word_addin_user'
                    });
                    
                    console.log('LLM response received:', response);
                    
                    // Process LLM results
                    this.processLLMResults(response.data);
                    
                } catch (error) {
                    console.error('LLM validation failed:', error);
                    
                    // Fallback to rule-based validation
                    console.log('Falling back to rule-based validation...');
                    await this.runValidationRules(documentData);
                    
                    // Show warning to user
                    setTimeout(() => {
                        alert('AI analysis unavailable. Switched to Quick Scan mode.');
                    }, 100);
                }
            }

            async callBackendAPI(requestData) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), this.backendConfig.timeout);

                try {
                    const response = await fetch(`${this.backendConfig.baseURL}/v1/analyze`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify(requestData),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
                    }

                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.message || 'Backend analysis failed');
                    }

                    return result;

                } catch (error) {
                    clearTimeout(timeoutId);
                    
                    if (error.name === 'AbortError') {
                        throw new Error('Analysis timeout. Document may be too large.');
                    }
                    
                    throw error;
                }
            }

            processLLMResults(llmData) {
                if (!llmData || !llmData.issues) {
                    console.warn('Invalid LLM response data');
                    return;
                }

                console.log(`Processing ${llmData.issues.length} LLM issues`);

                // Convert LLM issues to internal error format
                this.errors = llmData.issues.map(issue => ({
                    id: issue.id || this.generateErrorId(),
                    type: issue.category || 'LLM_ISSUE',
                    category: this.mapLLMSeverityToCategory(issue.severity),
                    title: issue.title || 'LLM Issue',
                    description: issue.description || 'Issue detected by AI',
                    location: {
                        paragraphIndex: this.findParagraphForIndex(issue.location?.startIndex || 0),
                        type: 'paragraph',
                        specificText: issue.location?.exactText || null,
                        startIndex: issue.location?.startIndex || 0,
                        endIndex: issue.location?.endIndex || 0
                    },
                    rule: issue.expected || 'LLM validation rule',
                    autoFixable: issue.autoFixable || false,
                    fix: issue.fix || null,
                    llmGenerated: true
                }));

                console.log(`Converted to ${this.errors.length} internal errors`);
            }

            mapLLMSeverityToCategory(severity) {
                const mapping = {
                    'Critical': 'CRITICAL',
                    'Warning': 'WARNING', 
                    'Suggestion': 'SUGGESTION'
                };
                return mapping[severity] || 'WARNING';
            }

            findParagraphForIndex(characterIndex) {
                // Simple heuristic to find paragraph index from character index
                // This is approximate since we don't have the exact character mapping
                // In a real implementation, you'd want to maintain a character-to-paragraph mapping
                if (characterIndex < 1000) return 0;
                if (characterIndex < 3000) return 1;
                if (characterIndex < 5000) return 2;
                if (characterIndex < 8000) return 3;
                if (characterIndex < 12000) return 4;
                return Math.min(Math.floor(characterIndex / 2000), 10); // Rough estimate
            }

            async extractDocumentData() {
                return await Word.run(async (context) => {
                    // Load document structure
                    const body = context.document.body;
                    const paragraphs = body.paragraphs;
                    const tables = body.tables;
                    
                    // Load properties
                    paragraphs.load("text,font,alignment,style,spaceAfter,spaceBefore,lineSpacing");
                    tables.load("*");
                    body.load("text");
                    
                    await context.sync();
                    
                    return {
                        paragraphs: paragraphs.items,
                        tables: tables.items,
                        fullText: body.text,
                        documentLength: body.text.length
                    };
                });
            }

            async runValidationRules(documentData) {
                // Font validation rules
                this.validateFonts(documentData);
                
                // Format validation rules
                this.validateFormatting(documentData);
                
                // Content validation rules
                this.validateContent(documentData);
                
                // Number validation rules
                this.validateNumbers(documentData);
                
                // Date validation rules
                this.validateDates(documentData);
            }

            validateFonts(data) {
                data.paragraphs.forEach((para, index) => {
                    const text = para.text.trim();
                    if (!text) return;

                    // Rule 1: Font family should be Calibri
                    if (para.font.name !== 'Calibri') {
                        this.addError({
                            type: 'FONT_ERROR',
                            category: 'CRITICAL',
                            title: 'Incorrect Font Family',
                            description: `Font should be Calibri, found "${para.font.name}"`,
                            location: { paragraphIndex: index, type: 'paragraph' },
                            rule: 'Font family must be Calibri',
                            autoFixable: true,
                            fix: { fontName: 'Calibri' }
                        });
                    }

                    // Rule 2: Font size validation
                    const fontSize = para.font.size;
                    let expectedSize = this.getExpectedFontSize(text, para.style);
                    
                    if (expectedSize && fontSize !== expectedSize) {
                        this.addError({
                            type: 'FONT_ERROR',
                            category: 'CRITICAL',
                            title: 'Incorrect Font Size',
                            description: `Expected ${expectedSize}pt, found ${fontSize}pt`,
                            location: { paragraphIndex: index, type: 'paragraph' },
                            rule: this.getFontSizeRule(text, para.style),
                            autoFixable: true,
                            fix: { fontSize: expectedSize }
                        });
                    }

                    // Rule 3: Line spacing should be 1.15
                    if (para.lineSpacing !== 1.15) {
                        this.addError({
                            type: 'FORMAT_ERROR',
                            category: 'WARNING',
                            title: 'Incorrect Line Spacing',
                            description: `Line spacing should be 1.15, found ${para.lineSpacing}`,
                            location: { paragraphIndex: index, type: 'paragraph' },
                            rule: 'Line spacing should always be 1.15',
                            autoFixable: true,
                            fix: { lineSpacing: 1.15 }
                        });
                    }
                });
            }

            validateFormatting(data) {
                data.paragraphs.forEach((para, index) => {
                    const text = para.text.trim();
                    if (!text) return;

                    // Rule 4: Capitalization rules
                    this.validateCapitalization(text, index);
                    
                    // Rule 5: Spacing rules (3pt for headings)
                    if (this.isHeading(text, para.style)) {
                        if (para.spaceAfter !== 3) {
                            this.addError({
                                type: 'FORMAT_ERROR',
                                category: 'WARNING',
                                title: 'Incorrect Heading Spacing',
                                description: `Headings should have 3pt spacing after, found ${para.spaceAfter}pt`,
                                location: { paragraphIndex: index, type: 'paragraph' },
                                rule: 'Headings should have 3pt spacing',
                                autoFixable: true,
                                fix: { spaceAfter: 3 }
                            });
                        }
                    }

                    // Rule 6: Slash spacing (space before and after '/')
                    this.validateSlashSpacing(text, index);
                });
            }

            validateContent(data) {
                data.paragraphs.forEach((para, index) => {
                    const text = para.text.trim();
                    if (!text) return;

                    // Rule 7: Prefix usage (no Mr., Miss, Ms.)
                    this.validatePrefixUsage(text, index);
                    
                    // Rule 8: Acronym usage
                    this.validateAcronymUsage(text, index);
                    
                    // Rule 9: Issue numbering
                    this.validateIssueNumbering(text, index);
                    
                    // Rule 10: Punctuation consistency
                    this.validatePunctuation(text, index);
                });
            }

            validateNumbers(data) {
                data.paragraphs.forEach((para, index) => {
                    const text = para.text.trim();
                    if (!text) return;

                    // Rule 11: Numbers 1-10 should be written in words
                    this.validateNumberRepresentation(text, index);
                    
                    // Rule 12: Currency should have INR prefix
                    this.validateCurrencyFormat(text, index);
                    
                    // Rule 13: Comma usage in numbers
                    this.validateCommaUsage(text, index);
                });
            }

            validateDates(data) {
                data.paragraphs.forEach((para, index) => {
                    const text = para.text.trim();
                    if (!text) return;

                    // Rule 14: Date format should be MMM, DD YYYY
                    this.validateDateFormat(text, index);
                    
                    // Rule 15: Expected closure dates should not be weekends
                    this.validateClosureDates(text, index);
                });
            }

            // Helper methods for validation rules

            getExpectedFontSize(text, style) {
                if (this.isReportTitle(text)) return 20;
                if (this.isHeading(text, style)) return 16;
                if (this.isSubHeading(text, style)) return 13;
                return 11; // Content
            }

            getFontSizeRule(text, style) {
                if (this.isReportTitle(text)) return 'Report title should be 20pt';
                if (this.isHeading(text, style)) return 'Headings should be 16pt';
                if (this.isSubHeading(text, style)) return 'Sub-headings should be 13pt';
                return 'Content should be 11pt';
            }

            isReportTitle(text) {
                return text.includes('INTERNAL AUDIT') || text.includes('Report Number:');
            }

            isHeading(text, style) {
                const headings = ['Executive Summary', 'Detailed Report', 'Appendix A'];
                return headings.some(h => text.includes(h)) || style === 'Heading1';
            }

            isSubHeading(text, style) {
                const subHeadings = ['Report Rating', 'Functional Overview', 'Audit Objective', 
                                   'Audit Scope', 'Scope Limitations', 'Audit Profile', 
                                   'Summary of Issues', 'Control Rating', 'Management Action Grade'];
                return subHeadings.some(sh => text.includes(sh)) || style === 'Heading2';
            }

            validateCapitalization(text, index) {
                // Check for team/policy capitalization
                const teamPolicyPattern = /(\w+)\s+(team|policy)/gi;
                const matches = text.matchAll(teamPolicyPattern);
                
                for (const match of matches) {
                    const [fullMatch, firstWord, lastWord] = match;
                    if (firstWord[0] !== firstWord[0].toUpperCase() || lastWord !== lastWord.toLowerCase()) {
                        this.addError({
                            type: 'FORMAT_ERROR',
                            category: 'WARNING',
                            title: 'Incorrect Capitalization',
                            description: `"${fullMatch}" should be "${firstWord.charAt(0).toUpperCase() + firstWord.slice(1).toLowerCase()} ${lastWord.toLowerCase()}"`,
                            location: { 
                                paragraphIndex: index, 
                                type: 'paragraph',
                                specificText: fullMatch
                            },
                            rule: 'First word capitalized, team/policy lowercase',
                            autoFixable: true
                        });
                    }
                }

                // Check for Board capitalization
                if (text.includes('board') && !text.includes('Board')) {
                    this.addError({
                        type: 'FORMAT_ERROR',
                        category: 'WARNING',
                        title: 'Board Capitalization',
                        description: '"Board" should always be capitalized',
                        location: { 
                            paragraphIndex: index, 
                            type: 'paragraph',
                            specificText: 'board'
                        },
                        rule: 'Board should always be capitalized',
                        autoFixable: true
                    });
                }
            }

            validateSlashSpacing(text, index) {
                const slashPattern = /\w\/\w/g;
                if (slashPattern.test(text)) {
                    this.addError({
                        type: 'FORMAT_ERROR',
                        category: 'SUGGESTION',
                        title: 'Missing Slash Spacing',
                        description: 'Add spaces before and after "/" (e.g., CEO / CFO)',
                        location: { paragraphIndex: index, type: 'paragraph' },
                        rule: 'Add space before and after usage of "/"',
                        autoFixable: true
                    });
                }
            }

            validatePrefixUsage(text, index) {
                const prefixPattern = /(Mr\.|Miss\.|Ms\.|Mrs\.)\s+\w+/g;
                const matches = text.matchAll(prefixPattern);
                
                for (const match of matches) {
                    const [fullMatch] = match;
                    this.addError({
                        type: 'FORMAT_ERROR',
                        category: 'WARNING',
                        title: 'Prefix Usage',
                        description: 'Remove prefixes (Mr., Miss, Ms.) before names',
                        location: { 
                            paragraphIndex: index, 
                            type: 'paragraph',
                            specificText: fullMatch
                        },
                        rule: 'Don\'t use prefix before names',
                        autoFixable: true
                    });
                }
            }

            validateAcronymUsage(text, index) {
                // Check for undefined acronyms
                const acronymPattern = /\b[A-Z]{2,}\b/g;
                const matches = text.match(acronymPattern);
                if (matches) {
                    matches.forEach(acronym => {
                        if (!this.isKnownAcronym(acronym)) {
                            this.addError({
                                type: 'FORMAT_ERROR',
                                category: 'SUGGESTION',
                                title: 'Undefined Acronym',
                                description: `Acronym "${acronym}" should be defined on first use`,
                                location: { paragraphIndex: index, type: 'paragraph' },
                                rule: 'Define acronyms at first use',
                                autoFixable: false
                            });
                        }
                    });
                }
            }

            validateIssueNumbering(text, index) {
                const issuePattern = /([HML])\.(\d+)\.(\d+)/g;
                const matches = text.matchAll(issuePattern);
                
                for (const match of matches) {
                    const [fullMatch, category, scope, sequence] = match;
                    if (!this.isValidIssueNumber(category, scope, sequence)) {
                        this.addError({
                            type: 'FORMAT_ERROR',
                            category: 'WARNING',
                            title: 'Invalid Issue Numbering',
                            description: `Issue number "${fullMatch}" doesn't follow correct sequence`,
                            location: { paragraphIndex: index, type: 'paragraph' },
                            rule: 'Issues should follow H.1.1, M.1.1, L.1.1 sequence',
                            autoFixable: false
                        });
                    }
                }
            }

            validatePunctuation(text, index) {
                // Check for missing punctuation at end of sentences
                const sentences = text.split(/[.!?]+/);
                sentences.forEach(sentence => {
                    if (sentence.trim() && !sentence.trim().match(/[.!?]$/)) {
                        this.addError({
                            type: 'FORMAT_ERROR',
                            category: 'SUGGESTION',
                            title: 'Missing Punctuation',
                            description: 'Consider adding proper punctuation',
                            location: { paragraphIndex: index, type: 'paragraph' },
                            rule: 'Maintain consistent punctuation',
                            autoFixable: false
                        });
                    }
                });
            }

            validateNumberRepresentation(text, index) {
                // Numbers 1-10 should be written in words
                const numberPattern = /\b(\d+)\b/g;
                const matches = text.matchAll(numberPattern);
                
                for (const match of matches) {
                    const [fullMatch, number] = match;
                    const num = parseInt(number);
                    if (num >= 1 && num <= 10 && !this.isYearOrException(text, number)) {
                        this.addError({
                            type: 'FORMAT_ERROR',
                            category: 'SUGGESTION',
                            title: 'Number Representation',
                            description: `Number "${number}" should be written in words`,
                            location: { paragraphIndex: index, type: 'paragraph' },
                            rule: 'Numbers 1-10 should be written in words',
                            autoFixable: true
                        });
                    }
                }
            }

            validateCurrencyFormat(text, index) {
                const currencyPattern = /(?<!INR\s)(\d+(?:\.\d+)?)\s*(lakhs?|crores?)/gi;
                if (currencyPattern.test(text)) {
                    this.addError({
                        type: 'FORMAT_ERROR',
                        category: 'WARNING',
                        title: 'Missing INR Prefix',
                        description: 'Currency amounts should have INR prefix',
                        location: { paragraphIndex: index, type: 'paragraph' },
                        rule: 'Use INR prefix before amounts',
                        autoFixable: true
                    });
                }
            }

            validateCommaUsage(text, index) {
                const numberPattern = /\b\d{4,}\b/g;
                const matches = text.match(numberPattern);
                if (matches) {
                    matches.forEach(number => {
                        if (!number.includes(',')) {
                            this.addError({
                                type: 'FORMAT_ERROR',
                                category: 'SUGGESTION',
                                title: 'Missing Comma in Numbers',
                                description: `Number "${number}" should use comma separators`,
                                location: { paragraphIndex: index, type: 'paragraph' },
                                rule: 'Use commas in large numbers',
                                autoFixable: true
                            });
                        }
                    });
                }
            }

            validateDateFormat(text, index) {
                const datePattern = /\b(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{4})\b/g;
                if (datePattern.test(text)) {
                    this.addError({
                        type: 'FORMAT_ERROR',
                        category: 'WARNING',
                        title: 'Incorrect Date Format',
                        description: 'Dates should be in MMM, DD YYYY format',
                        location: { paragraphIndex: index, type: 'paragraph' },
                        rule: 'Use MMM, DD YYYY date format',
                        autoFixable: true
                    });
                }
            }

            validateClosureDates(text, index) {
                if (text.toLowerCase().includes('expected closure date')) {
                    const datePattern = /(\w+\s+\d{1,2},\s+\d{4})/g;
                    const matches = text.match(datePattern);
                    if (matches) {
                        matches.forEach(dateStr => {
                            if (this.isWeekend(dateStr)) {
                                this.addError({
                                    type: 'FORMAT_ERROR',
                                    category: 'WARNING',
                                    title: 'Weekend Closure Date',
                                    description: `Expected closure date "${dateStr}" falls on weekend`,
                                    location: { paragraphIndex: index, type: 'paragraph' },
                                    rule: 'Closure dates should not be weekends',
                                    autoFixable: false
                                });
                            }
                        });
                    }
                }
            }

            // Helper methods

            isKnownAcronym(acronym) {
                const knownAcronyms = ['CEO', 'CFO', 'CTO', 'COO', 'CR', 'MAG', 'DOA', 'TSR', 'FAR', 'DVR', 'NTP', 'CCTV'];
                return knownAcronyms.includes(acronym);
            }

            isValidIssueNumber(category, scope, sequence) {
                // Basic validation - should start with 1.1 for each category
                return true; // Simplified for now
            }

            isYearOrException(text, number) {
                // Check if number is part of a year or other exception
                return text.includes(number + '24') || text.includes(number + '25') || text.includes('20' + number);
            }

            isWeekend(dateStr) {
                const date = new Date(dateStr);
                const dayOfWeek = date.getDay();
                return dayOfWeek === 0 || dayOfWeek === 6; // Sunday or Saturday
            }

            // Error management methods

            addError(error) {
                error.id = this.generateErrorId();
                this.errors.push(error);
            }

            generateErrorId() {
                return 'error_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            // Store error ranges for navigation without permanent highlighting
            async storeErrorRanges() {
                await Word.run(async (context) => {
                    // Load all paragraphs first
                    const paragraphs = context.document.body.paragraphs;
                    paragraphs.load("text");
                    await context.sync();

                    for (const error of this.errors) {
                        try {
                            // Check if paragraph index is valid
                            if (error.location.paragraphIndex >= paragraphs.items.length) {
                                console.warn(`Paragraph index ${error.location.paragraphIndex} is out of range`);
                                continue;
                            }

                            const paragraph = paragraphs.items[error.location.paragraphIndex];
                            let targetRange;
                            
                            // Try to find specific text range if available
                            if (error.location.specificText) {
                                try {
                                    const searchResults = paragraph.search(error.location.specificText, { 
                                        matchCase: false, 
                                        matchWholeWord: false 
                                    });
                                    searchResults.load("items");
                                    await context.sync();
                                    
                                    if (searchResults.items.length > 0) {
                                        targetRange = searchResults.items[0];
                                    } else {
                                        targetRange = paragraph.getRange();
                                    }
                                } catch (searchErr) {
                                    console.warn('Search failed, using paragraph range:', searchErr);
                                    targetRange = paragraph.getRange();
                                }
                            } else {
                                targetRange = paragraph.getRange();
                            }

                            // Store the range reference in the error for navigation (NO highlighting)
                            error.documentRange = targetRange;

                        } catch (err) {
                            console.warn('Could not store error range:', err);
                        }
                    }
                });
            }

            // Enhanced highlighting methods with precise text ranges

            async highlightErrors() {
                await Word.run(async (context) => {
                    // Clear existing highlights
                    await this.clearHighlights();

                    // Load all paragraphs first
                    const paragraphs = context.document.body.paragraphs;
                    paragraphs.load("text,font");
                    await context.sync();

                    for (const error of this.errors) {
                        try {
                            // Check if paragraph index is valid
                            if (error.location.paragraphIndex >= paragraphs.items.length) {
                                console.warn(`Paragraph index ${error.location.paragraphIndex} is out of range`);
                                continue;
                            }

                            const paragraph = paragraphs.items[error.location.paragraphIndex];
                            let targetRange;
                            
                            // Try to find specific text range if available
                            if (error.location.specificText) {
                                try {
                                    const searchResults = paragraph.search(error.location.specificText, { matchCase: false, matchWholeWord: false });
                                    searchResults.load("items");
                                    await context.sync();
                                    
                                    if (searchResults.items.length > 0) {
                                        targetRange = searchResults.items[0];
                                    } else {
                                        targetRange = paragraph.getRange();
                                    }
                                } catch (searchErr) {
                                    console.warn('Search failed, using paragraph range:', searchErr);
                                    targetRange = paragraph.getRange();
                                }
                            } else {
                                targetRange = paragraph.getRange();
                            }

                            // Apply highlighting with subtle background
                            targetRange.font.highlightColor = this.getErrorHighlightColor(error.category);
                            
                            // Store for later cleanup and navigation
                            this.highlightedRanges.push({
                                range: targetRange,
                                errorId: error.id,
                                category: error.category,
                                paragraphIndex: error.location.paragraphIndex
                            });

                            // Store the range reference in the error for navigation
                            error.documentRange = targetRange;

                        } catch (err) {
                            console.warn('Could not highlight error:', err);
                        }
                    }

                    await context.sync();
                });
            }

            getErrorHighlightColor(category) {
                const colors = {
                    'CRITICAL': '#FFEBEE',
                    'WARNING': '#FFF8E1', 
                    'SUGGESTION': '#E3F2FD'
                };
                return colors[category] || '#F5F5F5';
            }

            async clearHighlights() {
                await Word.run(async (context) => {
                    this.highlightedRanges.forEach(item => {
                        try {
                            item.range.font.highlightColor = null;
                        } catch (err) {
                            console.warn('Could not clear highlight:', err);
                        }
                    });
                    
                    this.highlightedRanges = [];
                    await context.sync();
                });
            }

            // UI methods

            showSection(sectionId) {
                document.querySelectorAll('.section').forEach(section => {
                    section.classList.add('hidden');
                });
                document.getElementById(sectionId).classList.remove('hidden');
            }

            displayResults() {
                const totalIssues = this.errors.length;
                
                // Update total issues counter
                document.getElementById('total-issues').textContent = `${totalIssues} issues found`;

                // Group errors by category and type
                const groupedErrors = this.groupErrors(this.errors);

                // Display corrections section
                this.displayCorrections(groupedErrors.corrections);
                
                // Display refinements section
                this.displayRefinements(groupedErrors.refinements);

                // Show/hide sections based on content
                document.getElementById('corrections-section').style.display = 
                    groupedErrors.corrections.totalCount > 0 ? 'block' : 'none';
                document.getElementById('refinements-section').style.display = 
                    groupedErrors.refinements.totalCount > 0 ? 'block' : 'none';
            }

            groupErrors(errors) {
                const corrections = {
                    totalCount: 0,
                    groups: {}
                };
                
                const refinements = {
                    totalCount: 0,
                    groups: {}
                };

                // Group errors by type and category
                errors.forEach(error => {
                    const isCorrection = error.category === 'CRITICAL' || error.category === 'WARNING';
                    const target = isCorrection ? corrections : refinements;
                    
                    target.totalCount++;
                    
                    // Group by error type
                    const groupKey = this.getErrorGroupKey(error);
                    if (!target.groups[groupKey]) {
                        target.groups[groupKey] = {
                            name: this.getErrorGroupName(error),
                            errors: [],
                            count: 0
                        };
                    }
                    
                    target.groups[groupKey].errors.push(error);
                    target.groups[groupKey].count++;
                });

                return { corrections, refinements };
            }

            getErrorGroupKey(error) {
                // Group similar error types together
                if (error.type === 'FONT_ERROR') {
                    if (error.title.includes('Font Family')) return 'font-family';
                    if (error.title.includes('Font Size')) return 'font-size';
                    return 'font-issues';
                }
                if (error.type === 'FORMAT_ERROR') {
                    if (error.title.includes('Capitalization')) return 'capitalization';
                    if (error.title.includes('Spacing')) return 'spacing';
                    if (error.title.includes('Date Format')) return 'date-format';
                    return 'formatting';
                }
                return error.type.toLowerCase();
            }

            getErrorGroupName(error) {
                const groupKey = this.getErrorGroupKey(error);
                const nameMap = {
                    'font-family': 'Font Family Issues',
                    'font-size': 'Font Size Issues',
                    'font-issues': 'Font Issues',
                    'capitalization': 'Capitalization Issues',
                    'spacing': 'Spacing Issues',
                    'date-format': 'Date Format Issues',
                    'formatting': 'Formatting Issues',
                    'format_error': 'Format Issues'
                };
                return nameMap[groupKey] || error.type.replace('_', ' ').toLowerCase();
            }

            displayCorrections(corrections) {
                document.getElementById('corrections-count').textContent = corrections.totalCount;
                const container = document.getElementById('corrections-groups');
                container.innerHTML = '';

                Object.entries(corrections.groups).forEach(([key, group]) => {
                    const groupElement = this.createIssueTypeGroup(key, group, 'corrections');
                    container.appendChild(groupElement);
                });
            }

            displayRefinements(refinements) {
                document.getElementById('refinements-count').textContent = refinements.totalCount;
                const container = document.getElementById('refinements-groups');
                container.innerHTML = '';

                Object.entries(refinements.groups).forEach(([key, group]) => {
                    const groupElement = this.createIssueTypeGroup(key, group, 'refinements');
                    container.appendChild(groupElement);
                });
            }

            createIssueTypeGroup(key, group, section) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'issue-type-group';
                groupDiv.dataset.groupKey = key;

                groupDiv.innerHTML = `
                    <div class="type-header">
                        <div class="type-info">
                            <span class="type-name">${group.name}</span>
                            <span class="type-count">${group.count}</span>
                        </div>
                        <span class="expand-icon">▶</span>
                    </div>
                    <div class="issue-instances">
                        ${group.errors.map(error => `
                            <div class="issue-instance" data-error-id="${error.id}">
                                <div class="instance-description">${error.description}</div>
                                <div class="instance-location">Paragraph ${error.location.paragraphIndex + 1} • Click to navigate</div>
                            </div>
                        `).join('')}
                    </div>
                `;

                // Add event listeners
                const header = groupDiv.querySelector('.type-header');
                header.addEventListener('click', () => {
                    groupDiv.classList.toggle('expanded');
                    this.toggleGroupHighlight(group.errors, groupDiv.classList.contains('expanded'));
                });

                // Add hover effect for entire group
                header.addEventListener('mouseenter', () => {
                    this.highlightErrorGroup(group.errors, true, section);
                });

                header.addEventListener('mouseleave', () => {
                    this.highlightErrorGroup(group.errors, false, section);
                });

                // Add click handlers for individual instances
                const instances = groupDiv.querySelectorAll('.issue-instance');
                instances.forEach(instance => {
                    const errorId = instance.dataset.errorId;
                    const error = group.errors.find(e => e.id === errorId);
                    
                    if (error) {
                        instance.addEventListener('click', async () => {
                            await this.navigateToError(error);
                            this.showErrorCard(error);
                        });

                        instance.addEventListener('mouseenter', () => {
                            this.addTemporaryColoredUnderline(error, true);
                        });

                        instance.addEventListener('mouseleave', () => {
                            this.addTemporaryColoredUnderline(error, false);
                        });
                    }
                });

                return groupDiv;
            }

            toggleGroupHighlight(errors, show) {
                errors.forEach(error => {
                    this.addTemporaryColoredUnderline(error, show);
                });
            }

            highlightErrorGroup(errors, show, section) {
                if (!show) {
                    // Clear all highlights when mouse leaves
                    errors.forEach(error => {
                        this.addTemporaryColoredUnderline(error, false);
                    });
                }
            }

            showErrorCard(error) {
                this.currentErrorCard = error;
                
                document.getElementById('error-type').textContent = error.category;
                document.getElementById('error-title').textContent = error.title;
                document.getElementById('error-description').textContent = error.description;
                document.getElementById('error-suggestion').textContent = error.rule;
                
                document.getElementById('error-card').classList.remove('hidden');
            }

            // Navigation method to jump to specific error in document
            async navigateToError(error) {
                console.log('Navigating to error:', error);
                try {
                    await Word.run(async (context) => {
                        console.log('Inside Word.run context');
                        
                        let targetRange;
                        
                        // Check if this is an LLM-generated error with character indices
                        if (error.llmGenerated && error.location.startIndex !== undefined && error.location.endIndex !== undefined) {
                            console.log(`Creating range from character indices: ${error.location.startIndex}-${error.location.endIndex}`);
                            
                            try {
                                // Create range directly from character indices
                                const body = context.document.body;
                                const bodyRange = body.getRange();
                                bodyRange.load("text");
                                await context.sync();
                                
                                // Validate indices
                                const docLength = bodyRange.text.length;
                                const startIndex = Math.min(Math.max(0, error.location.startIndex), docLength);
                                const endIndex = Math.min(Math.max(startIndex + 1, error.location.endIndex), docLength);
                                
                                console.log(`Document length: ${docLength}, using indices: ${startIndex}-${endIndex}`);
                                
                                // Create range from character positions
                                targetRange = bodyRange.getRange();
                                targetRange = targetRange.getRange(Word.RangeLocation.start).expandTo(
                                    bodyRange.getRange(Word.RangeLocation.start).getRange(Word.RangeLocation.after)
                                );
                                
                                // Try to get the specific range using search if we have exact text
                                if (error.location.exactText) {
                                    const searchResults = body.search(error.location.exactText, { 
                                        matchCase: false, 
                                        matchWholeWord: false 
                                    });
                                    searchResults.load("items");
                                    await context.sync();
                                    
                                    if (searchResults.items.length > 0) {
                                        targetRange = searchResults.items[0];
                                        console.log('Found text using document search');
                                    } else {
                                        console.log('Text not found, using approximate range');
                                        // Fallback: use approximate paragraph range
                                        await this.navigateToErrorFallback(error, context);
                                        return;
                                    }
                                }
                                
                            } catch (rangeError) {
                                console.warn('Character index navigation failed:', rangeError);
                                // Fallback to paragraph-based navigation
                                await this.navigateToErrorFallback(error, context);
                                return;
                            }
                            
                        } else {
                            // Use traditional paragraph-based navigation for rule-based errors
                            await this.navigateToErrorFallback(error, context);
                            return;
                        }

                        // Select and scroll to the range
                        console.log('Selecting range...');
                        targetRange.select();
                        await context.sync();
                        
                        console.log('Range selected successfully');
                        
                        // Add temporary visual emphasis
                        await this.addTemporaryEmphasis(targetRange);
                    });
                } catch (err) {
                    console.error('Navigation failed:', err);
                    alert(`Navigation failed: ${err.message}`);
                }
            }

            async navigateToErrorFallback(error, context) {
                console.log('Using fallback paragraph-based navigation');
                
                // Load all paragraphs first
                const paragraphs = context.document.body.paragraphs;
                paragraphs.load("text");
                await context.sync();
                
                // Check if paragraph index is valid
                if (error.location.paragraphIndex >= paragraphs.items.length) {
                    console.warn(`Paragraph index ${error.location.paragraphIndex} is out of range`);
                    throw new Error('Paragraph not found in document');
                }
                
                // Get the specific paragraph
                const paragraph = paragraphs.items[error.location.paragraphIndex];
                console.log('Paragraph loaded:', paragraph.text);

                let targetRange;
                
                // Try to find specific text if available
                if (error.location.specificText || error.location.exactText) {
                    const searchText = error.location.exactText || error.location.specificText;
                    console.log('Searching for specific text:', searchText);
                    try {
                        const searchResults = paragraph.search(searchText, { 
                            matchCase: false, 
                            matchWholeWord: false 
                        });
                        searchResults.load("items");
                        await context.sync();
                        
                        if (searchResults.items.length > 0) {
                            targetRange = searchResults.items[0];
                            console.log('Found specific text range');
                        } else {
                            console.log('Specific text not found, using paragraph range');
                            targetRange = paragraph.getRange();
                        }
                    } catch (searchErr) {
                        console.warn('Search failed, using paragraph range:', searchErr);
                        targetRange = paragraph.getRange();
                    }
                } else {
                    console.log('No specific text, using paragraph range');
                    targetRange = paragraph.getRange();
                }

                // Select and scroll to the range
                console.log('Selecting range...');
                targetRange.select();
                await context.sync();
                
                console.log('Range selected successfully');
                
                // Add temporary visual emphasis
                await this.addTemporaryEmphasis(targetRange);
            }

            // Add temporary visual emphasis when navigating to an error
            async addTemporaryEmphasis(range) {
                try {
                    await Word.run(async (context) => {
                        // Load font properties first
                        range.font.load("highlightColor");
                        await context.sync();
                        
                        // Store original highlighting
                        const originalColor = range.font.highlightColor;
                        
                        // Add emphasis
                        range.font.highlightColor = '#FFE082'; // Bright yellow
                        await context.sync();
                        
                        // Remove emphasis after delay
                        setTimeout(async () => {
                            try {
                                await Word.run(async (ctx) => {
                                    range.font.highlightColor = originalColor;
                                    await ctx.sync();
                                });
                            } catch (err) {
                                console.warn('Could not remove emphasis:', err);
                            }
                        }, 2000);
                    });
                } catch (err) {
                    console.warn('Could not add emphasis:', err);
                }
            }

            // Add temporary underline highlighting for hover effects
            async addTemporaryUnderline(error, shouldUnderline) {
                try {
                    await Word.run(async (context) => {
                        // Load all paragraphs first
                        const paragraphs = context.document.body.paragraphs;
                        paragraphs.load("text");
                        await context.sync();
                        
                        // Check if paragraph index is valid
                        if (error.location.paragraphIndex >= paragraphs.items.length) {
                            console.warn(`Paragraph index ${error.location.paragraphIndex} is out of range`);
                            return;
                        }
                        
                        // Get the specific paragraph
                        const paragraph = paragraphs.items[error.location.paragraphIndex];
                        let targetRange;
                        
                        // Try to find specific text if available
                        if (error.location.specificText) {
                            try {
                                const searchResults = paragraph.search(error.location.specificText, { 
                                    matchCase: false, 
                                    matchWholeWord: false 
                                });
                                searchResults.load("items");
                                await context.sync();
                                
                                if (searchResults.items.length > 0) {
                                    targetRange = searchResults.items[0];
                                } else {
                                    targetRange = paragraph.getRange();
                                }
                            } catch (searchErr) {
                                console.warn('Search failed, using paragraph range:', searchErr);
                                targetRange = paragraph.getRange();
                            }
                        } else {
                            targetRange = paragraph.getRange();
                        }

                        // Apply or remove underline and subtle highlight
                        if (shouldUnderline) {
                            targetRange.font.underline = 'Single';
                            targetRange.font.highlightColor = '#FFF8DC'; // Very light gold
                        } else {
                            targetRange.font.underline = 'None';
                            targetRange.font.highlightColor = null;
                        }
                        
                        await context.sync();
                    });
                } catch (err) {
                    console.warn('Could not add temporary underline:', err);
                }
            }

            // Add temporary color-coded underline highlighting for hover effects
            async addTemporaryColoredUnderline(error, shouldUnderline) {
                try {
                    await Word.run(async (context) => {
                        // Load all paragraphs first
                        const paragraphs = context.document.body.paragraphs;
                        paragraphs.load("text");
                        await context.sync();
                        
                        // Check if paragraph index is valid
                        if (error.location.paragraphIndex >= paragraphs.items.length) {
                            console.warn(`Paragraph index ${error.location.paragraphIndex} is out of range`);
                            return;
                        }
                        
                        // Get the specific paragraph
                        const paragraph = paragraphs.items[error.location.paragraphIndex];
                        let targetRange;
                        
                        // Try to find specific text if available
                        if (error.location.specificText) {
                            try {
                                const searchResults = paragraph.search(error.location.specificText, { 
                                    matchCase: false, 
                                    matchWholeWord: false 
                                });
                                searchResults.load("items");
                                await context.sync();
                                
                                if (searchResults.items.length > 0) {
                                    targetRange = searchResults.items[0];
                                } else {
                                    targetRange = paragraph.getRange();
                                }
                            } catch (searchErr) {
                                console.warn('Search failed, using paragraph range:', searchErr);
                                targetRange = paragraph.getRange();
                            }
                        } else {
                            targetRange = paragraph.getRange();
                        }

                        // Apply or remove color-coded underlines based on error category
                        if (shouldUnderline) {
                            // Set underline style and color based on error category
                            if (error.category === 'CRITICAL') {
                                // Red wavy underline for critical issues
                                targetRange.font.underline = 'Wavy';
                                targetRange.font.underlineColor = '#dc2626'; // Red
                                targetRange.font.highlightColor = '#fef2f2'; // Very light red background
                            } else if (error.category === 'WARNING') {
                                // Orange dotted underline for warnings
                                targetRange.font.underline = 'Dotted';
                                targetRange.font.underlineColor = '#f59e0b'; // Orange
                                targetRange.font.highlightColor = '#fffbeb'; // Very light orange background
                            } else if (error.category === 'SUGGESTION') {
                                // Blue solid underline for suggestions
                                targetRange.font.underline = 'Single';
                                targetRange.font.underlineColor = '#2563eb'; // Blue
                                targetRange.font.highlightColor = '#eff6ff'; // Very light blue background
                            } else {
                                // Default underline for other categories
                                targetRange.font.underline = 'Single';
                                targetRange.font.highlightColor = '#f9fafb'; // Very light gray background
                            }
                        } else {
                            // Remove all formatting
                            targetRange.font.underline = 'None';
                            targetRange.font.underlineColor = null;
                            targetRange.font.highlightColor = null;
                        }
                        
                        await context.sync();
                    });
                } catch (err) {
                    console.warn('Could not add temporary colored underline:', err);
                }
            }

            // Highlight specific error on hover
            async highlightSpecificError(error, shouldHighlight) {
                try {
                    await Word.run(async (context) => {
                        const highlightItem = this.highlightedRanges.find(item => item.errorId === error.id);
                        if (highlightItem && highlightItem.range) {
                            if (shouldHighlight) {
                                // Add hover effect
                                highlightItem.range.font.highlightColor = '#FFECB3'; // Light amber
                            } else {
                                // Restore original highlight
                                highlightItem.range.font.highlightColor = this.getErrorHighlightColor(error.category);
                            }
                            await context.sync();
                        }
                    });
                } catch (err) {
                    console.warn('Could not highlight specific error:', err);
                }
            }

            hideErrorCard() {
                document.getElementById('error-card').classList.add('hidden');
                this.currentErrorCard = null;
            }

            async fixCurrentError() {
                if (!this.currentErrorCard) return;

                try {
                    await this.fixSingleError(this.currentErrorCard);
                    this.hideErrorCard();
                    this.scanDocument(); // Re-scan to update results
                } catch (error) {
                    console.error('Error fixing issue:', error);
                    alert('Could not fix this issue automatically.');
                }
            }

            ignoreCurrentError() {
                if (!this.currentErrorCard) return;
                
                // Remove from errors list
                this.errors = this.errors.filter(e => e.id !== this.currentErrorCard.id);
                this.hideErrorCard();
                this.displayResults();
            }

            async fixAllErrors() {
                if (this.errors.length === 0) return;

                try {
                    const fixableErrors = this.errors.filter(e => e.autoFixable);
                    for (const error of fixableErrors) {
                        await this.fixSingleError(error);
                    }
                    this.scanDocument(); // Re-scan to update results
                } catch (error) {
                    console.error('Error fixing issues:', error);
                    alert('Could not fix all issues automatically.');
                }
            }

            async fixSingleError(error) {
                await Word.run(async (context) => {
                    // Load all paragraphs first
                    const paragraphs = context.document.body.paragraphs;
                    paragraphs.load("text,font,lineSpacing,spaceAfter");
                    await context.sync();
                    
                    // Check if paragraph index is valid
                    if (error.location.paragraphIndex >= paragraphs.items.length) {
                        console.warn(`Cannot fix error: Paragraph index ${error.location.paragraphIndex} is out of range`);
                        return;
                    }
                    
                    const paragraph = paragraphs.items[error.location.paragraphIndex];
                    
                    // Handle font and formatting fixes
                    if (error.fix) {
                        if (error.fix.fontName) {
                            paragraph.font.name = error.fix.fontName;
                        }
                        if (error.fix.fontSize) {
                            paragraph.font.size = error.fix.fontSize;
                        }
                        if (error.fix.lineSpacing) {
                            paragraph.lineSpacing = error.fix.lineSpacing;
                        }
                        if (error.fix.spaceAfter) {
                            paragraph.spaceAfter = error.fix.spaceAfter;
                        }
                    }
                    
                    // Handle text-based fixes
                    await this.fixTextIssues(error, paragraph, context);
                    
                    await context.sync();
                });
            }

            async fixTextIssues(error, paragraph, context) {
                try {
                    // Handle different types of text fixes based on error type
                    switch (error.title) {
                        case 'Prefix Usage':
                            await this.removePrefix(error, paragraph, context);
                            break;
                        case 'Incorrect Capitalization':
                            await this.fixCapitalization(error, paragraph, context);
                            break;
                        case 'Board Capitalization':
                            await this.fixBoardCapitalization(error, paragraph, context);
                            break;
                        case 'Missing Slash Spacing':
                            await this.fixSlashSpacing(error, paragraph, context);
                            break;
                        case 'Number Representation':
                            await this.fixNumberRepresentation(error, paragraph, context);
                            break;
                        case 'Missing INR Prefix':
                            await this.fixCurrencyPrefix(error, paragraph, context);
                            break;
                        case 'Missing Comma in Numbers':
                            await this.fixCommaInNumbers(error, paragraph, context);
                            break;
                        case 'Incorrect Date Format':
                            await this.fixDateFormat(error, paragraph, context);
                            break;
                        default:
                            console.log(`No text fix available for: ${error.title}`);
                    }
                } catch (err) {
                    console.warn('Could not apply text fix:', err);
                }
            }

            async removePrefix(error, paragraph, context) {
                // Remove prefixes like Mr., Ms., Miss, Mrs.
                const prefixPattern = /(Mr\.|Miss\.|Ms\.|Mrs\.)\s+(\w+)/g;
                const text = paragraph.text;
                const newText = text.replace(prefixPattern, '$2'); // Keep only the name
                
                if (newText !== text) {
                    paragraph.insertText(newText, Word.InsertLocation.replace);
                    await context.sync();
                }
            }

            async fixCapitalization(error, paragraph, context) {
                // Fix team/policy capitalization
                const teamPolicyPattern = /(\w+)\s+(team|policy)/gi;
                const text = paragraph.text;
                const newText = text.replace(teamPolicyPattern, (match, firstWord, lastWord) => {
                    return firstWord.charAt(0).toUpperCase() + firstWord.slice(1).toLowerCase() + ' ' + lastWord.toLowerCase();
                });
                
                if (newText !== text) {
                    paragraph.insertText(newText, Word.InsertLocation.replace);
                    await context.sync();
                }
            }

            async fixBoardCapitalization(error, paragraph, context) {
                // Fix Board capitalization
                const text = paragraph.text;
                const newText = text.replace(/\bboard\b/gi, 'Board');
                
                if (newText !== text) {
                    paragraph.insertText(newText, Word.InsertLocation.replace);
                    await context.sync();
                }
            }

            async fixSlashSpacing(error, paragraph, context) {
                // Add spaces around slashes
                const text = paragraph.text;
                const newText = text.replace(/(\w)\/(\w)/g, '$1 / $2');
                
                if (newText !== text) {
                    paragraph.insertText(newText, Word.InsertLocation.replace);
                    await context.sync();
                }
            }

            async fixNumberRepresentation(error, paragraph, context) {
                // Convert numbers 1-10 to words
                const numberWords = {
                    '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five',
                    '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine', '10': 'ten'
                };
                
                const text = paragraph.text;
                let newText = text;
                
                for (const [num, word] of Object.entries(numberWords)) {
                    // Only replace standalone numbers, not part of dates or years
                    const regex = new RegExp(`\\b${num}\\b(?!\\d)`, 'g');
                    if (regex.test(newText) && !this.isYearOrException(newText, num)) {
                        newText = newText.replace(regex, word);
                    }
                }
                
                if (newText !== text) {
                    paragraph.insertText(newText, Word.InsertLocation.replace);
                    await context.sync();
                }
            }

            async fixCurrencyPrefix(error, paragraph, context) {
                // Add INR prefix to currency amounts
                const text = paragraph.text;
                const currencyPattern = /(\d+(?:\.\d+)?)\s*(lakhs?|crores?)/gi;
                const newText = text.replace(currencyPattern, 'INR $1 $2');
                
                if (newText !== text) {
                    paragraph.insertText(newText, Word.InsertLocation.replace);
                    await context.sync();
                }
            }

            async fixCommaInNumbers(error, paragraph, context) {
                // Add commas to large numbers
                const text = paragraph.text;
                const numberPattern = /\b(\d{4,})\b/g;
                const newText = text.replace(numberPattern, (match) => {
                    return match.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                });
                
                if (newText !== text) {
                    paragraph.insertText(newText, Word.InsertLocation.replace);
                    await context.sync();
                }
            }

            async fixDateFormat(error, paragraph, context) {
                // Convert dates to MMM, DD YYYY format
                const text = paragraph.text;
                const datePattern = /\b(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})\b/g;
                
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                              'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                
                const newText = text.replace(datePattern, (match, day, month, year) => {
                    const monthIndex = parseInt(month) - 1;
                    if (monthIndex >= 0 && monthIndex < 12) {
                        return `${months[monthIndex]} ${day}, ${year}`;
                    }
                    return match; // Return original if invalid
                });
                
                if (newText !== text) {
                    paragraph.insertText(newText, Word.InsertLocation.replace);
                    await context.sync();
                }
            }
        }

        // Initialize Office.js
        Office.onReady((info) => {
            if (info.host === Office.HostType.Word) {
                // Initialize Sahayak
                window.sahayakAnalyzer = new SahayakDocumentAnalyzer();
                console.log('Sahayak Document Assistant initialized successfully!');
            }
        });
    </script>
</body>
</html>
